		library(ggplot2)
		library(gridExtra)
		
		# Define the kernels and their Fourier transforms
		kernels <- list(
		Truncated = function(x) ifelse(abs(x) <= 1, 1, 0),
		Bartlett = function(x) ifelse(abs(x) <= 1, 1 - abs(x), 0),
		Daniell = function(x) ifelse(x == 0, 1, sin(pi * x) / (pi * x)),
		Parzen = function(x) ifelse(abs(x) <= 0.5, 1 - 6 * x^2 + 6 * abs(x)^3,
		ifelse(abs(x) <= 1, 2 * (1 - abs(x))^3, 0)),
		QS = function(x) 3 / (pi * x)^2 * (sin(pi * x) / (pi * x) - cos(pi * x))
		)
		
		fourier_transforms <- list(
		Truncated = function(u) (1 / pi) * (sin(u) / u),
		Bartlett = function(u) (1 / (2 * pi)) * (sin(u / 2) / (u / 2))^2,
		Daniell = function(u) (1 / (2 * pi)) * ifelse(abs(u) <= pi, 1, 0),
		Parzen = function(u) (3 / (8 * pi)) * (sin(u / 4) / (u / 4))^4,
		QS = function(u) (3 / (4 * pi)) * (1 - (u / pi)^2) * ifelse(abs(u) <= pi, 1, 0)
		)
		
		# Define a sequence for x and u
		x_seq <- seq(-2, 2, length.out = 1000)
		u_seq <- seq(-10, 10, length.out = 1000)
		
		# Create plots for the kernels and their Fourier transforms side by side
		combined_plots <- lapply(names(kernels), function(name) {
			kernel_data <- data.frame(x = x_seq, y = sapply(x_seq, kernels[[name]]))
			fourier_data <- data.frame(x = u_seq, y = sapply(u_seq, fourier_transforms[[name]]))
			
			kernel_plot <- ggplot(kernel_data, aes(x, y)) + 
			geom_line() + 
			ggtitle(paste(name, "Kernel")) + 
			ylab("k(x)") + 
			theme_minimal()
			
			fourier_plot <- ggplot(fourier_data, aes(x, y)) + 
			geom_line() + 
			ggtitle(paste(name, "Fourier Transform")) + 
			ylab("K(u)") + 
			theme_minimal()
			
			grid.arrange(kernel_plot, fourier_plot, ncol = 2)
		})
		
		# Arrange the combined plots in one figure
		combined_grid <- do.call(grid.arrange, c(combined_plots, ncol = 1))
		
